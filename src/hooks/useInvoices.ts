
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';

export const useInvoices = () => {
  const queryClient = useQueryClient();

  const fetchInvoices = async () => {
    const { data, error } = await supabase.from('invoices').select('*').order('created_at', { ascending: false });
    if (error) throw new Error(error.message);
    return data;
  };

  const createInvoice = async (invoiceData: any) => {
    console.log('Creating invoice with data:', invoiceData);
    
    // Calculate totals
    const subtotal = invoiceData.service_charge + (invoiceData.additional_items?.reduce((sum: number, item: any) => sum + item.total_price, 0) || 0);
    const tax_amount = (subtotal * invoiceData.tax_rate) / 100;
    const total_amount = subtotal + tax_amount;

    // Fetch appointment details
    const { data: appointment, error: appointmentError } = await supabase
      .from('appointments')
      .select('*, patient_name, service_name, appointment_date_time')
      .eq('id', invoiceData.appointment_id)
      .single();

    if (appointmentError) throw new Error(appointmentError.message);

    // Create invoice
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        invoice_number: '', // Will be auto-generated by trigger
        appointment_id: invoiceData.appointment_id,
        patient_id: appointment.patient_id,
        patient_name: appointment.patient_name,
        appointment_date: appointment.appointment_date_time,
        service_name: appointment.service_name,
        service_charge: invoiceData.service_charge,
        tax_rate: invoiceData.tax_rate,
        tax_amount,
        subtotal,
        total_amount,
        payment_method: invoiceData.payment_method,
        notes: invoiceData.notes,
      })
      .select()
      .single();

    if (invoiceError) throw new Error(invoiceError.message);

    // Create additional items if any
    if (invoiceData.additional_items && invoiceData.additional_items.length > 0) {
      const items = invoiceData.additional_items.map((item: any) => ({
        invoice_id: invoice.id,
        ...item,
      }));

      const { error: itemsError } = await supabase.from('invoice_items').insert(items);
      if (itemsError) throw new Error(itemsError.message);
    }

    return invoice;
  };

  const invoicesQuery = useQuery({
    queryKey: ['invoices'],
    queryFn: fetchInvoices,
  });

  const createInvoiceMutation = useMutation({
    mutationFn: createInvoice,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });

  const updateInvoiceFn = async ({ id, updates }: { id: string, updates: any }) => {
    const { data, error } = await supabase
      .from('invoices')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    if (error) throw new Error(error.message);
    return data;
  };

  const updateInvoiceMutation = useMutation({
    mutationFn: updateInvoiceFn,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['invoices'] });
    },
  });

  return {
    invoices: invoicesQuery.data,
    isLoading: invoicesQuery.isLoading,
    createInvoice: createInvoiceMutation.mutateAsync,
    isCreating: createInvoiceMutation.isPending,
    updateInvoice: updateInvoiceMutation.mutateAsync,
    isUpdating: updateInvoiceMutation.isPending,
  };
};
